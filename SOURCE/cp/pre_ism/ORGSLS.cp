; ORGSLS / COP 
;
;
;		::PCPYCOP.DEF::
;*********************************************************************
;		CUSTOMER ORDER PROCESSING 
;		
;		RELEASED: AUGUST 1, 1984 (d70s10)
;		MODIFIED: 25-JUN-85 MRF 00968
;***********************************************************************
;
;		PROPRIETARY RIGHTS NOTICE:  All rights reserved.  This
;		material contains the valuable properties and trade secrets
;		of MCBA, Glendale, California, USA embodying substantial
;		creative effort and confidential information and ideas, no
;		part of which may be used and/or disclosed without MCBA's
;		duly authorized license agreement and/or written permission.
;
;		COPYRIGHT NOTICE:  Copyright <C> 1978, 1981, 1982, 1983, 1984
;		MCBA, AN UNPUBLISHED WORK.  ALL RIGHTS RESERVED.
;
;
;		COMPILE & LINK PER INSTALLATION OR TECHNICAL NOTES.
;
;:
;
;		REMOVES RECORDS MARKED FOR DELETION FROM SLSSUM
;		AND CORRECTS THE SLSIDX FILE AFTER DELETIONS
;
;		NOTE: NORMALLY WE WOULD CREATE A BRAND NEW INDEX FILE FROM
;		      THE SLSSUM FILE, AND THEN SORT IT. HOWEVER, IN THIS
;		      APPLICATION, THE FILE SIZE CAN GET HUGE, AND THUS
;		      SORTING MAY NOT BE POSIBLE BECAUSE SORT WORK SPACE IS
;		      NOT AVAILABLE. THEREFORE, THIS PROGRAM CORRECTS THE
;		      INDEX FILE (IE.. THE RELATIVE RECORD POINTER) BY KEEPING
;		      TRACK OF HOW MANY RECORDS HAVE ALREADY BEEN DELETED AND
;		      SUBTRACTING THAT NUMBER FROM THE RELATIVE RECORD POINTER.
;
;		IF THIS PROGRAM BECOMES EXXCESSIVELY SLOW, SUGGEST A BINARY
;		SEARCH ROUTINE BE SUBSTITUTED FOR THE LINEAR SEARCH OF DELSSR.
;
RECORD
	,A64,'THIS MATERIAL CONTAINS THE VALUABLE PROPERTIES AND TRADE SECRETS'
	,A62,'OF MCBA, EMBODYING CONFIDENTIAL INFORMATION AND IDEAS, NO PART'
	,A56,'OF WHICH MAY BE USED AND/OR DISCLOSED WITHOUT MCBAs DULY'
	,A55,'AUTHORIZED LICENSE AGREEMENT AND/OR WRITTEN PERMISSION.'
	,A61,'COPYRIGHT (C) MCBA, AN UNPUBLISHED WORK. ALL RIGHTS RESERVED.'
RECORD SLSSUM		
		.INCLUDE 'DEF:RD058A.DEF'
RECORD SLSDUM,X		
		.INCLUDE 'DEF:RD058B.DEF'
RECORD SLSIDX		
		.INCLUDE 'DEF:RD059A.DEF'
RECORD
	RECSS1	,20A351
RECORD ,X
	RECSS2	,167A42
RECORD BRACKS		
		.INCLUDE 'DEF:RD058C.DEF'
RECORD
	RDCNT	,D5
	WRTCNT	,D5
	RECNT	,D5
	ORGREC	,D5
	DELSSR	,1000D5		; LIST OF THE RECORD#S DELETED FROM SLSSUM FILE
	CNT	,D4,0000
	SUB	,D4
	N	,D3,001
	SSCNT	,D3,000
	SWITCH	,D1
	V	,D1
	COL2	,D2
	READ	,D1	,0
	WRITE	,D1	,1
	LOKCTL	,D1
PROC
	XCALL TERID (V)
	XCALL OUTPT (1,1,1,'PURGE INACTIVE SUMMARY RECORDS',V)
	SWITCH = 5
	XCALL FILES(2,'U',59,SWITCH)		;FILE # 59 -- SLSIDX FILE
	SWITCH = 5
	XCALL FILES(1,'U',58,SWITCH)		;FILE # 58 -- SLSSUM FILE
	LOKCTL = 1
	XCALL IO (1,SLSDUM,1,READ,LOKCTL)
	RECNT = REC058
	ORGREC = ORG058
	RDCNT = 1
	WRTCNT = 1
;********************************************************************************
;		REMOVE RECORDS MARKED FOR DELETION FROM SLSSUM FILE
READ,
	INCR RDCNT
	IF (RDCNT.GT.RECNT) GOTO EOF1
	LOKCTL = 1
	XCALL IO (1,SLSSUM,RDCNT,READ,LOKCTL)
	IF (SSPROD(1,6).EQ.BRACKS) GOTO EOF1
	IF (SSPROD(1,6).EQ.']]]DEL' .AND. CNT.LT.1000) GOTO DELETE
	INCR SSCNT
	RECSS1(SSCNT) = SLSSUM
	IF (SSCNT.EQ.20) CALL WRTSS1
	GOTO READ
DELETE,
	INCR CNT
	IF (CNT.EQ.1000) XCALL MESAG('MORE THAN 1000 DELETED - SEE INSTRUCTIONS',1)
	DELSSR(CNT) = RDCNT
	GOTO READ
;*******************************************************************************
;		WRITE BRACKETS AT END OF FILE
EOF1,
	IF (SSCNT.NE.0) CALL WRTSS1
	LOKCTL = 1
	XCALL IO (1,SLSSUM,1,READ,LOKCTL)
	ORG058 = WRTCNT
	REC058 = WRTCNT
	DEL058 = 0
	LOKCTL = 1
	XCALL IO (1,SLSSUM,1,WRITE,LOKCTL)
	SLSSUM = BRACKS
WRTBRK,
	IF (WRTCNT.EQ.RECNT) GOTO EOF2
	INCR WRTCNT
	LOKCTL = 1
	XCALL IO (1,SLSSUM,WRTCNT,WRITE,LOKCTL)
	GOTO WRTBRK
EOF2,
	RDCNT = 1
	WRTCNT = 1
;***********************************************************************************
;		CORRECT SLSIDX FILE BY SUBTRACTING OUT THE #OF DELETED
;		RECORDS (THAT HAD BEEN IN THE SLSSUM FILE IN A POSITION WITH
;		A LOWER RECORD# THAN THE CURRENT RECORD) FORM THE RELITIVE
;		RECORD# IN THE SLSIDX FILE
RDCIDX,
	IF (RDCNT.EQ.RECNT) GOTO EOF3
	INCR RDCNT
	LOKCTL = 1
	XCALL IO (2,SLSIDX,RDCNT,READ,LOKCTL)
	IF (IRC058.EQ.0) GOTO RDCIDX	;BYPASS INDEX FOR DELETED RECORDS
	SUB = 0
LOOP,
	INCR SUB
	IF (SUB.GT.CNT) GOTO OUT
	IF (DELSSR(SUB).LT.IRC058) GOTO LOOP
OUT,		;*** NOTE THIS CAN'T BE A DELETED RECORD (SEE ABOVE), SO WE
		;       ARE JUSTIFIED IN ASSUMING THAT SUB IS ONE BEYOND THE
		;	COUNT WE WANT. NOW WE CAN CORRECT THE RELATIVE RECORD #
	IRC058 = IRC058-(SUB-1)
	INCR SSCNT
	RECSS2(SSCNT) = SLSIDX
	IF (SSCNT.EQ.167) CALL WRTSS2
	GOTO RDCIDX
;***********************************************************************************
EOF3,
	IF (SSCNT.NE.0) CALL WRTSS2
	SLSIDX = BRACKS
WRBRK2,
	IF (RECNT.EQ.WRTCNT) GOTO END
	INCR WRTCNT
	LOKCTL = 1
	XCALL IO (2,SLSIDX,WRTCNT,WRITE,LOKCTL)
	GOTO WRBRK2
END,
	XCALL FILES(1,'U',58,4)
	XCALL FILES(2,'I',59,4)
	XCALL PGCHN ('CP:SSMENU',1)
;****************************************************************************
WRTSS1,
	INCR WRTCNT
	LOKCTL = 1
	XCALL IO (1,RECSS1(N),WRTCNT,WRITE,LOKCTL)
	IF (N.EQ.SSCNT) GOTO OUT1
	INCR N
	GOTO WRTSS1
OUT1,
	SSCNT = 0
	N = 1
	RETURN
;*****************************************************************************
WRTSS2,
	INCR WRTCNT
	LOKCTL = 1
	XCALL IO (2,RECSS2(N),WRTCNT,WRITE,LOKCTL)
	IF (N.EQ.SSCNT) GOTO OUT2
	INCR N
	GOTO WRTSS2
OUT2,
	SSCNT = 0
	N = 1
	RETURN
	END
